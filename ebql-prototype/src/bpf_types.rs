use std::fmt::Display;

use crate::bpf_types;

#[derive(Clone, Debug)]
pub struct TracepointEvent {
    pub path: String,
    // /sys/kernel/tracing/events/...
}

impl TracepointEvent {
    // TODO: when I convert this to a generic Event interface, add better logic
    pub fn section_name(&self) -> String {
        self.path.clone()
    }
}

// Originally, I made this a struct. However, that allows users to arbitrarily
// specify any combination, many of which might make no sense (e.g.
// "sys_enter_pread64, buf, string"). For now, I'm hard-coding the fields that
// are provided, but later (at least for tracepoints) this can be feasibly
// auto-generated by some build script.
//
// Actuallyyyy this is probably infeasible, there's likely to be conflicts
// between different program types for a specific <field, type> combo (e.g. what
// if `buf` is char* in one, but uintptr_t in another? maybe I'm worrying idk
// but this seems like a not uncommon edge case).
//
// ok back to struct it is
#[derive(Clone, Debug)]
pub struct Field {
    pub _event: Option<TracepointEvent>,
    // offset within args[]. TODO: this should ideally not be necessary following some code-gen,
    // but for now there's no other way to extract values from
    pub _off: Option<usize>,
    pub _name: String,
    pub _type: Type,
}

impl Display for Field {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} {}", self._type, self._name)
    }
}

// Why U/S? vmlinux.h seems to typedef `unsigned <int type>` -> `u#`, and `<int
// type>` -> `s#`.
#[derive(Clone, Debug)]
pub enum Type {
    U8,
    U16,
    U32,
    U64,
    S8,
    S16,
    S32,
    S64,
    UChar,
    SChar,
    String(usize),
}

impl Type {
    // Returns the size of the type (in bytes)
    pub fn size(&self) -> usize {
        use bpf_types::Type::*;
        match self {
            U8 => 1,
            U16 => 2,
            U32 => 4,
            U64 => 8,
            S8 => 1,
            S16 => 2,
            S32 => 4,
            S64 => 8,
            UChar => 1,
            SChar => 1,
            // TODO: see if I can incorporate this as char <name>[LEN]?
            // TODO: figure out better way to handle this conflict ope
            String(_len) => *_len,
        }
    }
}

impl Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use bpf_types::Type::*;
        match self {
            U8 => write!(f, "u8"),
            U16 => write!(f, "u16"),
            U32 => write!(f, "u32"),
            U64 => write!(f, "u64"),
            S8 => write!(f, "s8"),
            S16 => write!(f, "s16"),
            S32 => write!(f, "s32"),
            S64 => write!(f, "s64"),
            UChar => write!(f, "u8"),
            SChar => write!(f, "s8"),
            // TODO: see if I can incorporate this as char <name>[LEN]?
            // TODO: figure out better way to handle this conflict ope
            String(_len) => write!(f, "char *"),
        }
    }
}
